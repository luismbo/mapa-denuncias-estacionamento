<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>v8 Mapa — Denúncias de Estacionamento</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  />
  <!-- MarkerCluster CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css"
  />
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css"
  />

  <style>
    html, body, #map { height: 100%; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; }
    #app {
      display: grid;
      grid-template-columns: 320px 1fr;
      height: 100vh;
      gap: 0;
    }
    #sidebar {
      padding: 12px;
      box-sizing: border-box;
      background: #f8f9fb;
      border-right: 1px solid #e2e6ea;
      overflow: auto;
    }
    #map-wrap { position: relative; }
    #controls { margin-bottom: 12px; }
    h1 { font-size: 18px; margin: 0 0 8px 0; }
    label.filter-item { display: flex; align-items: center; gap: 8px; margin-bottom: 6px; }
    .badge { font-size: 12px; color: #666; margin-left: 6px; }
    #status { font-size: 13px; color: #333; margin-top: 8px; }
    button, .btn {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
    }
    button:active { transform: translateY(1px); }
    .small { padding: 4px 8px; font-size: 12px; }
    #filters { margin-top: 8px; }
    #loadMore { margin-top: 8px; }
    .muted { color: #666; font-size: 13px; }
    a.link { color: #0366d6; text-decoration: none; }
    pre { white-space: pre-wrap; word-wrap: break-word; font-size: 12px; background: #fff; padding: 8px; border-radius: 6px; border: 1px solid #eee; }
  </style>
</head>
<body>
  <div id="app">
    <aside id="sidebar" aria-labelledby="title">
      <h1 id="title">Mapa de denúncias</h1>

      <div id="controls">
        <div>
          <button id="fit" class="btn small">Ajustar à visualização</button>
          <button id="clear" class="btn small">Limpar marcadores</button>
        </div>

        <div style="margin-top:10px;">
          <label for="limit">Número de pontos a carregar:</label>
          <select id="limit" aria-label="limit">
            <option value="200" selected>200</option>
            <option value="500">500</option>
            <option value="1000">1000</option>
            <option value="5000">5000</option>
          </select>
          <button id="reload" class="btn small">Carregar</button>
        </div>
      </div>

      <div>
        <strong>Filtrar por tipo de evento</strong>
        <div id="filters" role="group" aria-label="Filtros de tipos">
          <div class="muted">Carregando tipos…</div>
        </div>
      </div>

      <div style="margin-top:12px;">
        <button id="toggleAll" class="btn small">Marcar / Desmarcar tudo</button>
      </div>

      <div id="status" aria-live="polite">
        <div>Marcadores visíveis: <span id="visibleCount">0</span></div>
        <div>Carregados: <span id="loadedCount">0</span></div>
      </div>

      <div id="debug" style="margin-top:8px;font-size:13px;color:#444"></div>

      <hr style="margin:12px 0;" />

      <div>
        <div class="muted">API:</div>
        <div><a class="link" href="https://denuncia-estacionamento.app/api.html" target="_blank">Documentação</a></div>
        <div style="margin-top:6px;"><a class="link" href="https://api.denuncia-estacionamento.app/penalties_list" target="_blank">/penalties_list</a></div>
      </div>

      <hr style="margin:12px 0;" />
      <div>
        <div class="muted">Observações:</div>
        <ul>
          <li>Se o endpoint de denúncias for diferente substitua a variável <code>DATA_URL</code> no script.</li>
          <li>O script tenta detectar latitude/longitude em campos comuns; se necessário ajuste a função <code>getLatLng</code>.</li>
        </ul>
      </div>
    </aside>

    <div id="map-wrap">
      <div id="map"></div>
    </div>
  </div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  ></script>

  <!-- MarkerCluster JS -->
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <script>
    // Configuration: change these if the API endpoints differ
    const BASE_API = 'https://api.denuncia-estacionamento.app';
    const PENALTIES_LIST_URL = BASE_API + '/penalties_list';
    // Primary data URL - if the real endpoint is different, change here.
    // Common possibilities: /penalties, /penalties.json, /reports, /denuncias
    const DATA_URL = BASE_API + '/penalties';
    // Defaults
    const DEFAULT_LIMIT = 200;
    const DEFAULT_TYPE = 'passeios';

    // Map & UI state
    const map = L.map('map', { zoomControl: true }).setView([39.4, -8.2], 7); // default: Portugal center
    const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Marker cluster group
    const markers = L.markerClusterGroup();
    map.addLayer(markers);

    // Storage of all loaded items and marker references
    let allItems = []; // { item: <object>, marker: <L.marker>, typeKey: string }
    let currentTypeFilter = new Set(); // selected types (if empty -> treat as all selected)

    // UI elements
    const filtersEl = document.getElementById('filters');
    const visibleCountEl = document.getElementById('visibleCount');
    const loadedCountEl = document.getElementById('loadedCount');
    const limitEl = document.getElementById('limit');

    // Utility: robustly get lat/lng from a payload item (recursive search)
    function getLatLng(item) {
      if (!item) return null;

      const isFiniteNumber = v => typeof v === 'number' && isFinite(v);
      const toNumber = v => {
        if (isFiniteNumber(v)) return v;
        if (typeof v === 'string' && v.trim() !== '') {
          const n = Number(v.replace(',', '.'));
          return isFiniteNumber(n) ? n : null;
        }
        return null;
      };

      const isLat = v => v >= -90 && v <= 90;
      const isLng = v => v >= -180 && v <= 180;

      function pairFromArray(arr) {
        if (!Array.isArray(arr) || arr.length < 2) return null;
        const a = toNumber(arr[0]);
        const b = toNumber(arr[1]);
        if (a === null || b === null) return null;
        // Try [lat, lng]
        if (isLat(a) && isLng(b)) return [a, b];
        // Try [lng, lat]
        if (isLat(b) && isLng(a)) return [b, a];
        return null;
      }

      function pairFromObject(obj) {
        if (!obj || typeof obj !== 'object') return null;
        const keys = Object.keys(obj).map(k => k.toLowerCase());
        const get = k => toNumber(obj[k]);

        // common pairs
        const mapping = [
          ['lat','lon'], ['lat','lng'], ['latitude','longitude'], ['latitude','lng'], ['lat','longitude']
        ];
        for (const [aKey,bKey] of mapping) {
          if (aKey in obj && bKey in obj) {
            const a = toNumber(obj[aKey]);
            const b = toNumber(obj[bKey]);
            if (a !== null && b !== null && isLat(a) && isLng(b)) return [a,b];
            if (a !== null && b !== null && isLat(b) && isLng(a)) return [b,a];
          }
        }

        // coordinates as object {lat, lng} or {latitude, longitude}
        if ('lat' in obj && 'lng' in obj) {
          const a = toNumber(obj.lat), b = toNumber(obj.lng);
          if (a !== null && b !== null) return [a,b];
        }
        if ('latitude' in obj && 'longitude' in obj) {
          const a = toNumber(obj.latitude), b = toNumber(obj.longitude);
          if (a !== null && b !== null) return [a,b];
        }

        // Heuristic: detect keys that include 'lat' and keys that include 'lon'|'long'|'lng'
        let latKey = null, lonKey = null;
        for (const k of Object.keys(obj)) {
          const kl = k.toLowerCase();
          if (!latKey && kl.includes('lat')) latKey = k;
          if (!lonKey && (kl.includes('lon') || kl.includes('long') || kl.includes('lng'))) lonKey = k;
        }
        if (latKey && lonKey) {
          const a = toNumber(obj[latKey]);
          const b = toNumber(obj[lonKey]);
          if (a !== null && b !== null) return [a,b];
        }

        return null;
      }

      // deep search for arrays/objects that look like coordinates
      function find(obj, depth = 0) {
        if (!obj || depth > 8) return null;
        // Arrays
        if (Array.isArray(obj)) {
          const p = pairFromArray(obj);
          if (p) return p;
          for (const el of obj) {
            const r = find(el, depth+1);
            if (r) return r;
          }
          return null;
        }
        // Objects
        if (typeof obj === 'object') {
          // GeoJSON geometry coordinates [lng, lat]
          if (obj.geometry && Array.isArray(obj.geometry.coordinates)) {
            const p = pairFromArray(obj.geometry.coordinates);
            if (p) return p;
          }
          if (obj.geojson && Array.isArray(obj.geojson.coordinates)) {
            const p = pairFromArray(obj.geojson.coordinates);
            if (p) return p;
          }
          // direct coordinate object
          const fromObj = pairFromObject(obj);
          if (fromObj) return fromObj;

          // check common container keys
          for (const k of ['location','coordinates','position','point','coords','geometry']) {
            if (k in obj) {
              const r = find(obj[k], depth+1);
              if (r) return r;
            }
          }

          // otherwise scan values
          for (const v of Object.values(obj)) {
            const r = find(v, depth+1);
            if (r) return r;
          }
        }
        return null;
      }

      const result = find(item);
      return result || null;
    }

    // Utility: determine the "type" key on an item
    function getTypeKey(item) {
      // Try fields commonly used: penalty, type, kind, category
      if (item.penalty) return String(item.penalty);
      if (item.type) return String(item.type);
      if (item.kind) return String(item.kind);
      if (item.category) return String(item.category);
      // Some APIs use 'penalty_id' or 'penalty_type'
      if (item.penalty_type) return String(item.penalty_type);
      if (item.penalty_id) return String(item.penalty_id);
      // If none found, return 'unknown'
      return 'unknown';
    }

    // Build popup content (simple)
    function buildPopupHtml(item) {
      const lines = [];
      if (item.title) lines.push('<strong>' + escapeHtml(item.title) + '</strong>');
      // list some common fields
      ['description','detail','comment','created_at','date','city','address','street'].forEach(k => {
        if (item[k]) lines.push('<div><strong>' + escapeHtml(k) + ':</strong> ' + escapeHtml(String(item[k])) + '</div>');
      });
      // fallback: show JSON snippet
      lines.push('<hr><div><small>Dados completos:</small><pre>' + escapeHtml(JSON.stringify(item, null, 2)) + '</pre></div>');
      return lines.join('\n');
    }

    function escapeHtml(s) {
      return s.replace(/[&<>\"']/g, function (m) {
        return ({ '&':'&amp;', '<':'&lt;', '>':'&gt;', '"':'&quot;', "'":'&#39;' })[m];
      });
    }

    // Fetch the list of penalty types and build filter controls
    async function fetchPenaltiesList() {
      // Try the canonical endpoint first, but attempt fallbacks if the response is empty/unexpected.
      try {
        const res = await fetch(PENALTIES_LIST_URL);
        if (res.ok) {
          const data = await res.json();
          if (Array.isArray(data) && data.length > 0) { buildFilterControls(data); return; }
          if (data && Array.isArray(data.data) && data.data.length > 0) { buildFilterControls(data.data); return; }
          if (data && typeof data === 'object') {
            const vals = Object.values(data);
            if (vals.length > 0) { buildFilterControls(vals); return; }
          }
          console.warn('penalties_list returned no usable items');
        } else {
          console.warn('penalties_list returned', res.status);
        }
      } catch (err) {
        console.warn('Erro ao obter /penalties_list:', err);
      }

      // Try some common alternative locations (.json or trailing slash)
      const altUrls = [PENALTIES_LIST_URL + '.json', PENALTIES_LIST_URL + '/'];
      for (const u of altUrls) {
        try {
          const r = await fetch(u);
          if (!r.ok) continue;
          const d = await r.json();
          if (Array.isArray(d) && d.length > 0) { buildFilterControls(d); return; }
          if (d && Array.isArray(d.data) && d.data.length > 0) { buildFilterControls(d.data); return; }
          if (d && typeof d === 'object') {
            const vals = Object.values(d);
            if (vals.length > 0) { buildFilterControls(vals); return; }
          }
        } catch (e) {
          console.warn('fallback fetch failed for', u, e);
        }
      }

      // Last resort: fetch a small sample from DATA_URL and derive types from the items
      try {
        const sampleUrl = new URL(DATA_URL);
        sampleUrl.searchParams.set('limit', 20);
        const sr = await fetch(sampleUrl.toString());
        if (sr.ok) {
          const sd = await sr.json();
          let items = Array.isArray(sd) ? sd : (sd && Array.isArray(sd.data) ? sd.data : (sd && typeof sd === 'object' ? Object.values(sd) : []));
          const types = Array.from(new Set(items.map(it => getTypeKey(it)).filter(Boolean)));
          if (types.length > 0) { buildFilterControls(types); return; }
        } else {
          console.warn('sample DATA_URL returned', sr.status);
        }
      } catch (e) {
        console.warn('sample fetch failed', e);
      }

      // If everything failed, show a helpful message
      filtersEl.innerHTML = '<div class="muted">Não foi possível carregar tipos. Verifique a URL: ' + PENALTIES_LIST_URL + '</div>';
    }

    // Create filter checkboxes from retrieved list
    function buildFilterControls(list) {
      filtersEl.innerHTML = '';
      if (!Array.isArray(list) || list.length === 0) {
        filtersEl.innerHTML = '<div class="muted">Lista vazia</div>';
        return;
      }
      list.forEach(entry => {
        let id, name;
        if (typeof entry === 'string') { id = entry; name = entry; }
        else if (entry && (entry.id || entry.key)) { id = entry.id || entry.key; name = entry.name || entry.title || id; }
        else { id = JSON.stringify(entry); name = String(entry); }

        const key = String(id);

        const wrapper = document.createElement('label');
        wrapper.className = 'filter-item';
        wrapper.innerHTML = `
          <input type="checkbox" data-type="${escapeHtml(key)}" />
          <span>${escapeHtml(name)}</span>
        `;
        filtersEl.appendChild(wrapper);
        // apply default selection: select only DEFAULT_TYPE if it exists
        try {
          const cb = wrapper.querySelector('input[type=checkbox]');
          if (cb) cb.checked = (key === DEFAULT_TYPE);
        } catch (e) { }
      });

      // initialize currentTypeFilter based on checked boxes (defaults applied above)
      currentTypeFilter = new Set(Array.from(filtersEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.dataset.type));

      // attach event
      filtersEl.addEventListener('change', onFilterChange);
    }

    function onFilterChange() {
      const checked = Array.from(filtersEl.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.dataset.type);
      currentTypeFilter = new Set(checked);
      applyFilters();
    }

    // Toggle all
    document.getElementById('toggleAll').addEventListener('click', () => {
      const boxes = Array.from(filtersEl.querySelectorAll('input[type=checkbox]'));
      const allChecked = boxes.every(cb => cb.checked);
      boxes.forEach(cb => cb.checked = !allChecked);
      onFilterChange();
    });

    // Load data
    async function loadData(limit = 1000) {
      loadedCountEl.textContent = '...';
      clearData();

      // Determine whether the API expects a per-type path (e.g. /penalties/:type)
      const hasFilterControls = filtersEl.querySelectorAll('input[type=checkbox]').length > 0;

      // Helper to find an array of items that contain geolocation fields anywhere in a nested response
      function findGeoArray(obj, depth = 0) {
        if (!obj || depth > 6) return null;
        if (Array.isArray(obj)) {
          if (obj.length > 0 && obj.some(it => getLatLng(it))) return obj;
          for (const el of obj) {
            const found = findGeoArray(el, depth + 1);
            if (found) return found;
          }
          return null;
        }
        if (typeof obj === 'object') {
          for (const k of Object.keys(obj)) {
            const found = findGeoArray(obj[k], depth + 1);
            if (found) return found;
          }
        }
        return null;
      }

      // Helper to normalize response into an array of items (robust against nested shapes)
      const normalize = data => {
        if (!data) return [];
        if (Array.isArray(data)) return data;
        if (data && Array.isArray(data.data)) return data.data;
        if (data && Array.isArray(data.items)) return data.items;
        if (data && Array.isArray(data.results)) return data.results;
        // try common single-level object -> values
        if (data && typeof data === 'object') {
          const vals = Object.values(data);
          // if values are array and contain geo items, pick first
          for (const v of vals) {
            if (Array.isArray(v) && v.some(it => getLatLng(it))) return v;
          }
        }
        // deep search for any nested array with geo items
        const found = findGeoArray(data);
        return found || [];
      };

      // Debug helper: write to debug panel and console
      function debug(msg) {
        try {
          const el = document.getElementById('debug');
          if (el) el.textContent = msg;
        } catch (e) { /* ignore */ }
        console.log('[map-debug]', msg);
      }

      try {
        let aggregatedItems = [];

        if (hasFilterControls) {
          // Determine which types to request. If user selected none (empty set), treat as all types.
          let typesAvailable = Array.from(filtersEl.querySelectorAll('input[type=checkbox]')).map(cb => cb.dataset.type);
          let typesToFetch = currentTypeFilter && currentTypeFilter.size > 0 ? Array.from(currentTypeFilter) : typesAvailable;

          // If we still have no types (unexpected), fall back to single DATA_URL
          if (!typesToFetch || typesToFetch.length === 0) {
            typesToFetch = null;
          }

          if (typesToFetch) {
            // Fetch each type endpoint in parallel: DATA_URL/<type>?limit=...
            const fetchPromises = typesToFetch.map(type => {
              const url = new URL(DATA_URL + '/' + encodeURIComponent(type));
              url.searchParams.set('limit', limit);
              return fetch(url.toString()).then(res => ({ res, type })).catch(err => ({ err, type }));
            });

            const results = await Promise.all(fetchPromises);

            // Collect successful responses
            for (const r of results) {
              if (r.err) {
                console.warn('Erro ao buscar tipo', r.type, r.err);
                continue;
              }
              const res = r.res;
              if (!res.ok) {
                console.warn('Requisição retornou', res.status, 'for type', r.type);
                continue;
              }
              const data = await res.json();
              const items = normalize(data);
              console.log('[map-debug] fetched type', r.type, '-> items:', items.length);
              aggregatedItems = aggregatedItems.concat(items);
            }
          }
        }

        // If no per-type fetches were performed (no filters), fallback to generic DATA_URL
        if (!aggregatedItems || aggregatedItems.length === 0) {
          const url = new URL(DATA_URL);
          url.searchParams.set('limit', limit);
          const res = await fetch(url.toString());
          if (!res.ok) throw new Error('Erro ao carregar dados: ' + res.status);
          const data = await res.json();
          const items = normalize(data);
          console.log('[map-debug] fetched generic DATA_URL -> items:', items.length);
          aggregatedItems = aggregatedItems.concat(items);
        }

        // Add markers
        let withCoords = 0, withoutCoords = 0;
        for (const item of aggregatedItems) {
          const latlng = getLatLng(item);
          if (!latlng) { withoutCoords++; continue; }
          withCoords++;
          const typeKey = getTypeKey(item);
          const popup = buildPopupHtml(item);
          const marker = L.marker(latlng, { title: typeKey });
          marker.bindPopup(popup, { maxWidth: 450 });
          marker._ourType = typeKey; // store for filtering
          markers.addLayer(marker);
          allItems.push({ item, marker, typeKey });
        }

        debug('fetched: ' + aggregatedItems.length + ' items — with coords: ' + withCoords + ', without coords: ' + withoutCoords);
        loadedCountEl.textContent = allItems.length;
        applyFilters();

        if (markers.getLayers().length > 0) {
          document.getElementById('fit').disabled = false;
          map.fitBounds(markers.getBounds(), { maxZoom: 16 });
        } else {
          document.getElementById('fit').disabled = true;
        }
      } catch (err) {
        console.error(err);
        loadedCountEl.textContent = 'Erro';
        alert('Erro ao carregar dados: ' + err.message + '\nVerifique a URL DATA_URL e CORS.');
      }
    }

    // Apply filters to markers
    function applyFilters() {
      let visible = 0;
      // If no filter controls (not loaded) => show everything
      const hasFilters = filtersEl.querySelectorAll('input[type=checkbox]').length > 0;
      // Helper: recursively search item for string values that match any selected filter
      function itemMatchesFilter(obj, filterSet, depth = 0) {
        if (!obj || depth > 8) return false;
        if (typeof obj === 'string' || typeof obj === 'number') {
          const s = String(obj).toLowerCase();
          for (const f of filterSet) if (String(f).toLowerCase() === s) return true;
          return false;
        }
        if (Array.isArray(obj)) {
          for (const v of obj) if (itemMatchesFilter(v, filterSet, depth+1)) return true;
          return false;
        }
        if (typeof obj === 'object') {
          for (const v of Object.values(obj)) if (itemMatchesFilter(v, filterSet, depth+1)) return true;
          return false;
        }
        return false;
      }

      allItems.forEach(entry => {
        const type = entry.typeKey;
        let shouldShow = (!hasFilters) || currentTypeFilter.size === 0 || currentTypeFilter.has(type);
        if (!shouldShow && hasFilters && currentTypeFilter.size > 0) {
          // try matching against the item's content (attributes, nested fields)
          shouldShow = itemMatchesFilter(entry.item, currentTypeFilter);
        }

        if (shouldShow) {
          markers.addLayer(entry.marker);
          visible++;
        } else {
          markers.removeLayer(entry.marker);
        }
      });
      visibleCountEl.textContent = visible;
    }

    // Clear currently loaded markers
    function clearData() {
      markers.clearLayers();
      allItems = [];
      visibleCountEl.textContent = 0;
      loadedCountEl.textContent = 0;
    }

    // UI buttons
    document.getElementById('fit').addEventListener('click', () => {
      if (markers.getLayers().length === 0) return alert('Nenhum marcador visível.');
      map.fitBounds(markers.getBounds(), { maxZoom: 16 });
    });

    document.getElementById('clear').addEventListener('click', () => {
      clearData();
    });

    document.getElementById('reload').addEventListener('click', () => {
      const limit = Number(limitEl.value) || 1000;
      loadData(limit);
    });

    // init
    (async function init() {
      // initial load of types (wait so we don't call generic /penalties before types exist)
      try {
        await fetchPenaltiesList();
      } catch (e) {
        console.warn('fetchPenaltiesList failed during init', e);
      }
      const initialLimit = Number(limitEl.value) || 1000;
      loadData(initialLimit);
    })();
  </script>
</body>
</html>
